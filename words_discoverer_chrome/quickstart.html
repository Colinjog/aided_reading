<!DOCTYPE html>
<html>
  <head>
    <title>Drive API Quickstart</title>
    <meta charset='utf-8' />
  </head>
  <body>
    <p>Drive API Quickstart</p>

    <!--Add buttons to initiate auth sequence and sign out-->
    <button id="authorize-button" style="display: none;">Authorize</button>
    <button id="signout-button" style="display: none;">Sign Out</button>

    <pre id="content"></pre>

    <script type="text/javascript">
      // Client ID and API key from the Developer Console

      // Array of API discovery doc URLs for APIs used by the quickstart
      var DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];

      // Authorization scopes required by the API; multiple scopes can be
      // included, separated by spaces.
      //var SCOPES = 'https://www.googleapis.com/auth/drive.metadata.readonly https://www.googleapis.com/auth/drive.file';
      var SCOPES = 'https://www.googleapis.com/auth/drive.metadata.readonly https://www.googleapis.com/auth/drive.file';

      var authorizeButton = document.getElementById('authorize-button');
      var signoutButton = document.getElementById('signout-button');


      /**
       *  On load, called to load the auth2 library and API client library.
       */
      function handleClientLoad() {
        gapi.load('client:auth2', initClient);
      }

      /**
       *  Initializes the API client library and sets up sign-in state
       *  listeners.
       */
      function initClient() {
        gapi.client.init({
          apiKey: API_KEY,
          clientId: CLIENT_ID,
          discoveryDocs: DISCOVERY_DOCS,
          scope: SCOPES
        }).then(function () {
          console.log("client inited!");
          // Listen for sign-in state changes.
          gapi.auth2.getAuthInstance().isSignedIn.listen(updateSigninStatus);

          // Handle the initial sign-in state.
          updateSigninStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
          authorizeButton.onclick = handleAuthClick;
          signoutButton.onclick = handleSignoutClick;
        });
      }

      /**
       *  Called when the signed in status changes, to update the UI
       *  appropriately. After a sign-in, the API is called.
       */
      function updateSigninStatus(isSignedIn) {
        if (isSignedIn) {
          authorizeButton.style.display = 'none';
          signoutButton.style.display = 'block';
          test_sync();
        } else {
          authorizeButton.style.display = 'block';
          signoutButton.style.display = 'none';
        }
      }

      /**
       *  Sign in the user upon button click.
       */
      function handleAuthClick(event) {
        gapi.auth2.getAuthInstance().signIn();
      }

      /**
       *  Sign out the user upon button click.
       */
      function handleSignoutClick(event) {
        gapi.auth2.getAuthInstance().signOut();
      }


      function simple_success(drive_obj_id) {
          console.log('Object exists! Object id: ' + drive_obj_id);
      }


      function simple_failure(error_msg) {
          console.error('Unable to ensure wd dir. Error: ' + error_msg);
      }


      function list_to_set(src_list) {
          result = {};
          for (var i = 0; i < src_list.length; ++i) {
              result[src_list[i]] = 1;
          }
          return result;
      }


      function substract_from_set(lhs_set, rhs_set) {
          for (var key in rhs_set) {
              if (rhs_set.hasOwnProperty(key) && lhs_set.hasOwnProperty(key)) {
                  delete lhs_set[key];
              }
          }
      }

      function add_to_set(lhs_set, rhs_set) {
          for (var key in rhs_set) {
              if (rhs_set.hasOwnProperty(key)) {
                  lhs_set[key] = 1;
              }
          }
      }

      
      function serialize_vocabulary(entries) {
          keys = [];
          for (var key in entries) {
              if (entries.hasOwnProperty(key)) {
                  keys.push(key);
              }
          }
          return keys.join('\r\n');
      }

      function parse_vocabulary(text) {
          var lines = text.split('\n');
          var found = [];
          for (var i = 0; i < lines.length; ++i) {
              var word = lines[i];
              if (i + 1 === lines.length && word.length <= 1)
                  break;
              if (word.slice(-1) === '\r') {
                  word = word.slice(0, -1);
              }
              found.push(word);
          }
          return found;
      }


      function create_new_dir(dir_name, fail_cb, success_cb) {
          var body= {"name": dir_name, "mimeType": "application/vnd.google-apps.folder", "appProperties": {"wdfile": '1'}};
          var req_params = {'path': 'https://www.googleapis.com/drive/v3/files/', 'method': 'POST', 'body': body};
          gapi.client.request(req_params).then(function(jsonResp, rawResp) {
              console.log(jsonResp);
              if (jsonResp.status == 200) {
                  success_cb(jsonResp.result.id);
              } else {
                  fail_cb('Bad dir create status: ' + jsonResp.status);
              }
          });
      }


      function create_new_file(fname, parent_dir_id, success_cb, fail_cb) {
          //var params = {"name": fname, "mimeType": "text/plain", "parents": [parent_dir_id], "uploadType": "media"};
          //var params = {"name": fname, "mimeType": "application/vnd.google-apps.file", "parents": [parent_dir_id], "uploadType": "media"};
          //var body = {"name": fname, "parents": [parent_dir_id], "mimeType": "text/plain"};
          var body = {"name": fname, "parents": [parent_dir_id], "appProperties": {"wdfile": '1'}, "mimeType": "text/plain"};
          //var req_params = {'path': 'https://www.googleapis.com/upload/drive/v3/files?uploadType=media', 'method': 'POST', 'body': body};
          //var params = 'params': {"uploadType": "media"};
          //var req_params = {'path': 'https://www.googleapis.com/upload/drive/v3/files', 'method': 'POST', 'body': body, "params": params};
          var req_params = {'path': 'https://www.googleapis.com/drive/v3/files', 'method': 'POST', 'body': body};
          gapi.client.request(req_params).then(function(jsonResp, rawResp) {
              console.log(jsonResp);
              if (jsonResp.status == 200) {
                  success_cb(jsonResp.result.id);
              } else {
                  fail_cb('Bad file create status: ' + jsonResp.status);
              }
          });
      }


      function upload_file_content(file_id, file_content, fail_cb, success_cb) {
          var req_params = {'path': 'https://www.googleapis.com/upload/drive/v3/files/' + file_id, 'method': 'PATCH', 'body': file_content};
          gapi.client.request(req_params).then(function(jsonResp, rawResp) {
              console.log(jsonResp);
              if (jsonResp.status == 200) {
                  success_cb();
              } else {
                  fail_cb('Bad upload content status: ' + jsonResp.status);
              }
          });
      }


      function fetch_file_content(file_id, success_cb) {
          // https://developers.google.com/drive/v3/web/manage-downloads
          var full_query_url = 'https://www.googleapis.com/drive/v3/files/' + file_id + '?alt=media';
          gapi.client.request({'path': full_query_url, 'method': 'GET'}).then(function(jsonResp, rawResp) {
              console.log(jsonResp);
              if (jsonResp.status != 200) {
                  fail_cb('Bad status: ' + jsonResp.status + ' for getting content of file: ' + file_id);
                  return;
              }
              var file_content = jsonResp.body; // let's pretend that we have content in this variable...
              success_cb(file_id, file_content);
          });
      }


      function find_gdrive_id(query, fail_cb, found_cb, not_found_cb) {
          //generic function to find single object id
          var full_query_url = 'https://www.googleapis.com/drive/v3/files?q=' + encodeURIComponent(query);
          gapi.client.request({'path': full_query_url, 'method': 'GET'}).then(function(jsonResp, rawResp) {
              console.log(jsonResp);
              if (jsonResp.status != 200) {
                  fail_cb('Bad status: ' + jsonResp.status + ' for query: ' + query);
                  return;
              }
              if (jsonResp.result.files.length > 1) {
                  fail_cb('More than one object found for query: ' + query);
                  return;
              } else if (jsonResp.result.files.length == 1) {
                  var drive_id = jsonResp.result.files[0].id
                  found_cb(drive_id);
                  return;
              }
              not_found_cb();
          });
      }
    

      function sync_vocabulary(dir_id, vocab, success_cb, fail_cb) {
          merge_and_upload_vocab = function(file_id, file_content) {
              vocab_list = parse_vocabulary(file_content);
              var entries = list_to_set(vocab_list);
              substract_from_set(entries, vocab.deleted);
              add_to_set(entries, vocab.added);
              merged_content = serialize_vocabulary(entries);

              set_merged_vocab = function() {
                  for (var key in entries) {
                     if (entries.hasOwnProperty(key)) {
                         console.log('adding entry to set: ' + key);
                     }
                  }
                  success_cb('fake-file-id');
              }
              upload_file_content(file_id, merged_content, fail_cb, set_merged_vocab);
          }

          merge_vocab_to_cloud = function(file_id) {
              fetch_file_content(file_id, merge_and_upload_vocab);
          }

          var vocab_file_name = vocab.name + ".txt";
          var file_query = "name = '" + vocab_file_name + "' and trashed = false and appProperties has { key='wdfile' and value='1' } and '" + dir_id + "' in parents";
          create_new_file_wrap = function() {
              create_new_file(vocab_file_name, dir_id, merge_vocab_to_cloud, fail_cb);
              var new_added = {};
              add_to_set(new_added, vocab.all);
              add_to_set(new_added, vocab.added);
              vocab.added = new_added;
          }
          find_gdrive_id(file_query, fail_cb, merge_vocab_to_cloud, create_new_file_wrap);
      }


      function backup_vocabulary(dir_id, vocab, success_cb, fail_cb) {
          merge_and_upload_backup = function(file_id, file_content) {
              vocab_list = parse_vocabulary(file_content);
              var entries = list_to_set(vocab_list);
              add_to_set(entries, vocab.all);
              add_to_set(entries, vocab.deleted);
              add_to_set(entries, vocab.added);
              merged_content = serialize_vocabulary(entries);
              upload_file_content(file_id, merged_content, fail_cb, success_cb);
          }
          merge_backup_to_cloud = function(file_id) {
              fetch_file_content(file_id, merge_and_upload_backup);
          }

          var backup_file_name = "." + vocab.name + ".backup";
          var backup_query = "name = '" + backup_file_name + "' and trashed = false and appProperties has { key='wdfile' and value='1' } and '" + dir_id + "' in parents";
          create_new_backup_file_wrap = function() {
              create_new_file(backup_file_name, dir_id, merge_backup_to_cloud, fail_cb);
          }
          find_gdrive_id(backup_query, fail_cb, merge_backup_to_cloud, create_new_backup_file_wrap);
      }


      function perform_full_sync(vocab, success_cb, fail_cb) {
          var dir_name = "Words Discoverer Sync";
          var dir_query = "name = '" + dir_name + "' and trashed = false and appProperties has { key='wdfile' and value='1' }";
          backup_and_sync_vocabulary = function(dir_id) {
              sync_vocabulary_wrap = function() {
                  sync_vocabulary(dir_id, vocab, success_cb, fail_cb);
              }
              backup_vocabulary(dir_id, vocab, sync_vocabulary_wrap, fail_cb);
          }
          create_new_dir_wrap = function() {
              create_new_dir(dir_name, fail_cb, backup_and_sync_vocabulary);
          }
          find_gdrive_id(dir_query, fail_cb, backup_and_sync_vocabulary, create_new_dir_wrap); 
      }

      
      function test_sync() {
          var words = {"world": 1, "industry": 1, "leather": 1, "member": 1};
          var added = {"destiny": 1};
          //var deleted = {};
          var deleted = {"hello": 1, "stack": 1};

          // just use all words for added instead of first_sync flag
          // on first sync deleted is empty and added is the whole vocabulary
          var vocab = {"name": "main", "all": words, "added": added, "deleted": deleted};
          perform_full_sync(vocab, simple_success, simple_failure);
      }


    </script>

    <script async defer src="https://apis.google.com/js/api.js"
      onload="this.onload=function(){};handleClientLoad()"
      onreadystatechange="if (this.readyState === 'complete') this.onload()">
    </script>
  </body>
</html>
